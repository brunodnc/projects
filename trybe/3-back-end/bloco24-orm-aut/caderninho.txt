Ferramentas de Object-Relational Mapping provê umaforma de manipular o banco de dados através de métodos pré-feitos no JavaScript, Sequelize será a ferramenta ORM utilizada.

npm install sequelize // para instalar o sequelize,
npm install sequelize-cli // para instalar o cliente que gerenciará a relação entre o sequelize e o banco de dados (requer também o npm install mysql2)
npx sequelize-cli init // iniciará o sequelize, gerando as pastas necessárias para o seu funcionamento, uma delas é o arquivo config/config.json onde estará as configurações da conexão com o database
npx sequelize db:create // gera o banco de dados a partir da conexão estabelecida no config.json
npx sequelize model:generate --name Nome --attributes Atributo:string // comando que cria um model (modelo do javascript da tabela) e inicia uma migration (versionamento que carrega o registro das alterações feitas no banco de dados) no banco de dados;


No model gerado haverá lá uma função criadora do modelo, que poderá ser - entre outras coisas - modificada para adicionar novas colunas no banco de dados, por exemplo

const Tabela = (sequelize, DataTypes) => {
	const Tabela = seuqelize.define('Tabela', {
		name: DataTypes.STRING,
		age: DataTypes.INTEGER,
		});
	};

// Detalhe que na migration o nome da tabela é dado no plural, enquanto no model é dado no singular.
Uma das vantagens do versionamento do banco de dados feito através das migrations é que, tal qual o git, se tem gravações dos diversos estados de mudança do banco de dados ao longo do tempo
Da mesma forma que no model adicionou-se uma nova coluna 'age', no exemplo acima, deve-se também adicionar como uma nova migration essa nova coluna.

npx sequelize migration:generate --name nome-da-migração // cria uma nova migração para adicionar alterações na tabela;



npx sequelize seed:generate --name users // Cria um seed em branco, o qual vai ser utilizado pelo o sequelize, quando configurado, para popular o banco de dados.
npx sequelize db:seed:all // executa o seed
npx sequelize db:seed:undo:all // reverte o seed

Depois da implementação do Model já é possível manipular os dados do banco de dados com o sequelize, por exemplo:

const express = require('express');
const { User } = require('../models');
const router = express.Router();

router.get('/', async (req, res) => {
	try {
		const users = await User.findAll() // método do sequelize para buscar todos os usuários diretamente no model User, importado acima
		return res.status(200).json(users);
		}
	catch (e) {
		console.log(e.message);
		res.status(500).json({ message: Erro!});
		};
	});
module.exports = router;	

Outros métodos possíveis do sequelize:

.findByPk(pk) // Encontrar pela primary key
.findOne({ where: email}) // busca apenas um que cumpra os critérios do where
.create({name, email}) // Cria uma nova entrada na tabela
.update({name, email}, {where: pk}) // atualiza os dados com base no where
.destroy({where: pk}) // retira uma linha da tabela com base em sua primary key


Para configurar no sequelize uma primarya key e uma foreign key: 

Na migration:

	{ id: {
		allowNull: false,
		autoIncrement: true,
		primaryKey: true,
		type: Sequelize.INTEGER
			},
	foreign_id: {
		type: Sequelize.INTEGER,
		allowNull: false,
		onUpdate: 'CASCADE',
		onDelete: 'CASCADE',
		field: 'foreing_id'
		references: {
			mode: 'foreingTableName',
			key: 'id'
				}
			}
		}
	}

No model utiliza-se as funções hasOne() // usada na tabela de origem da foreign key e belongsTo() sinalizada na tabela que consome a foreing key: -> User.hasOne(Phone) e Phone.belongsTo(User)

ModelName.associate = (models) => {
	ModelName.belongsTo(models.ForeignModelName, { foreignKey: 'foreign_id', as: 'relation_alias' });
	};

e

ForeignModelName.associate = (models) => {
	ForeignModelName.hasOne(models.ModelName, { foreignKey: 'foreign_id', as: 'relation_alias' });
	};

Para associação 1:N ou N:N utiliza-se hasMany() e ou belongsToMany()

Em uma suposta migration N:N:
module.exports = {
	up: async (queryInterface, Sequelize) => {
		await queryInterface.createTable('UserBooks', {
			user_id: {
				type: Sequelize.INTEGER,
				references: {
					model: 'Users',
					key: 'user_id'
					}
				onUpdate: 'CASCADE',
				onDelete: 'CASCADE',
				primaryKey: true
				},
			book_id: {
				type: Sequelize.INTEGER,
				references: {
					model: 'Books',
					key: 'book_id'
					}
				onUpdate: 'CASCADE',
				onDelete: 'CASCADE',
				primaryKey: true
				}
			});
		}
	down: async (queryInterface, _Sequelize) => {
		await queryInterface.dropTable('UserBooks');
		}
	};
Num suposto model fica assim:

UserBook.associate = (models) => {
	models.Book.belongsToMany(models.User, {
		as: 'users',
		through: UserBook,
		foreignKey: 'book_id',
		otherKey: 'user_id'
		});
	models.User.belongsToMany(models.Book, {
		as: 'books',
		through: UserBook,
		foreignKey: 'user_id',
		otherKey: 'book_id'
		});
	};


Com o sequelize é possível incluir dados advindos de foreing keys e remover informações desnecessárias das querias passando tal configuração como parâmetro da função de busca:
const searchResult = await ModelName.findOne(
	{ where: id, include: [
		{model: ForeignModel, as: 'alias', attributes: {
			 exclude: ['column_to_be_excluded'] 
			} 
		}]
	});

Há opções também de garantir a atomicidade das transações no banco de dados, isto é, ou ela roda por completo, ou não, o sequelie consegue gerenciar automaticamente essas transações basta apenas sinalizar para ele quais as operações fazem parte do mesmo grupo da seguinte forma:

const result = await sequelize.transaction(async (t) => {
	const data1 = await User.create({name, data}), { transaction: t});
	const data2 = Model.create((city, user_id}, { transaction: t });
	return res.status(201).json({message: 'success!});
	});

O JWT é o JSON Web Token, um token de autenticação que, mesmo sendo público, permite apenas o detentor da senha, isto é, o usuário, consiga alterar as informações que o token carrega.
O token é composto por dois objetos, o header, que contém suas proprias informaçoes, e o payload que contém os dados e permissões da pessoa usuária.

O header contém duas propriedades:

{
	"alg": "HS256", // é o tipo do algoritmo de criptografia empregado
	"typ": "JWT" // é o tipo do token
}

E o payload contém os dados:

{
	name: 'Usuario'
	admin: false,
}

Para gerar a assinatura do token o header e o payload devem estar codificados em base64 para então serem criptografados pelo algoritmo definido no header, por exemplo:

import { hmac } from 'hmac';

const base64 = (string) => Buffer.from(string).toString('base64');

const secret = 'senha'

const signature = hmac(secret, `${base54(header)}.${base64(payload)}`);
const token = `${base64(header)}.${base64(payload)}.${base64(assinatura)}`;


