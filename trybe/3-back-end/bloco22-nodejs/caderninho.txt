O node possui módulos internos, locais e de terceiros

Os módulos internos, ou core modules em inglês, são instalados juntos com o node que formam as funcionalidades mínimas do node, cada um deles possuindo seu próprio contexto, mesmo assim, ainda é preciso importá-los nas aplicações para serem utilizados. São eles os principais:

http - inclui classes, métodos e eventos para criar um servidor http
url - inclui métodos para a manipulação de url
querystring - inclui métodos relacionados com querystrings
path - inclui métodos para trabalhar com o caminho dos arquivos
fs - inclui classes, métodos e eventos para lidar com a entrada e saída de arquivos
util - inclui funções úteis.

Módulos locais são os módulos do node que funcionam em paralelo, mas encontram-se separados da aplicação em questão, estes funcionam de forma autônoma o bastante para a publicação no NPM

Módulos de terceiros são os módulos criados por outrem e disponibilizados através do npm

Existem duas formas para se importar um módulo no Node, o Módulo ES6 e CommonJS.

O método do ECMAScript6, que usa as palavras-chaves import e export, não são aceitos por padrão pelo Node, e por isso, é necessário também o uso de transpiladores como Babel ou o do TypeScript

O sistema de importação e exportação de módulos do CommonJS pode ser utilizado no Node.js por padrão, nele utiliza-se o module.exports = 'valor a ser exportado' para exportar, e const NomeDaVariavelImportada = require('./caminhoDoArquivoQueTemModuleExport')

comandos básicos npm:

npm init - cria um pacote node
npm run <comando> - roda um script pre-determinado pelo package.son, que definirá tanto o <comando> quanto seu processo
npm start - atalho para 'npm run start', ele, por convenção, 'roda' o código do pacote
npm install nomeDoPacote - busca, baixa e instalada do registro do NPM um determinado pacote
npm install -D nomeDoPacote - mesma coisa que o de cima, porém sinaliza que este pacote não é necessário para a execução da aplicação, e estará presente apenas em seu desenvolvimento
npm install - busca nas dependências do package.json o nome dos pacotes que serão em sequência baixados

---

3 métodos de leitura de arquivo com o node:

Detalhe, os daodos desses arquivos ficam armazenados na memória RAM!!

Método síncrono:

const fs = require('fs');
try {
	const data = fs.readFileSync(pathDoArquivo, encoding); // onde encoding = o modo que o node interpretará os bytes do arquivo, o formato padrão do encoding, caso não especificado é o raw buffer,
	console.log(data);
} catch(err) {
	console.error('Erro ao ler arquivo: ' + err.path )
	console.log(err);
}

Método assíncrono sem Promise:

const fs = require('fs');
fs.readFile(pathDoArquivo, encoding, (err, data) => {
	if (err) {
	console.error('Erro': + err);
	process.exit(1);
	}
	console.log('Arquivo lido: ' + data);
});

Método assíncrono com Promise:

const fs = require('fs').promises;
fs.readFile(pathDoArquivo, encoding)
	.then(data => {
		console.log(data);
		})
	.catch(err => {
		console.error('erro : ' + err);
		process.exit(1);
		});

Para escrever dados um em arquivo usando promises:

const fs = require('fs).promises;
fs.writeFile(caminhoDoArquivo, texto)
	.then(() => {
console.log('sucesso'
	))
	.catch((err) => {
		console.error(err);
		});

Escrever dados em um arquivo usando async/æwait:

const fs = require('fs').promises;
const funcaoAsyn = async () => {
	try {
		await fs.writeFile(caminhoDoArquivo, texto)
		console.log('sucesso');
		}
	catch (err) {
		console.error(err);
		}
	}

---

Promise.all é um método que possibilita a manipulação de várias promises passando-as como seu parâmatro, e quando todas forem resolvidas, poderá ser tratado como um array de resultados, empregando apenas um catch para tratar o erro na rejeição de qualquer uma delas.
Por exemplo:

const fs = require('fs').promises;

Promise.all([
	fs.readfile(arquivo1),
	fs.readfile(arquivo2)
	fs.readfile(arquivo3)
	])
	.then(([file1, file2, file3]) => {
		const tamanhoTotalDosArquivos = file1.byteLength + file2.byteLength + file3.byteLength;
		console.log('Tamanho total: ' + tamanhoTotalDosArquivos);
		})
	.catch((err) => {
		console.error(err.message);
		});

É possível estabelecer alguns parâmetros de execução para alguns métodos do fs, por exemplo, na função .writeFile, ela pode receber como terceiro parâmetro um objeto para configurá-la, veja o exemplo:

fs.writeFile(caminhoDoArquivo, texto, { flag: wx })

wx significa que ele não reescreverá o arquivo caso ele já exista, funcionando apenas escrevendo um novo arquivo;
nodejs.org/api/fs.html#fs_file_system_flags - documentação que explica cada flag possível


